{"version":3,"file":"static/js/57.41a216f4.chunk.js","mappings":"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","sources":["../node_modules/lenis/packages/core/src/maths.ts","../node_modules/lenis/packages/core/src/animate.ts","../node_modules/lenis/packages/core/src/dimensions.ts","../node_modules/lenis/packages/core/src/debounce.ts","../node_modules/lenis/packages/core/src/emitter.ts","../node_modules/lenis/packages/core/src/virtual-scroll.ts","../node_modules/lenis/packages/core/src/lenis.ts","../node_modules/lenis/package.json"],"sourcesContent":["/**\r\n * Clamp a value between a minimum and maximum value\r\n *\r\n * @param min Minimum value\r\n * @param input Value to clamp\r\n * @param max Maximum value\r\n * @returns Clamped value\r\n */\r\nexport function clamp(min: number, input: number, max: number) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n/**\r\n * Truncate a floating-point number to a specified number of decimal places\r\n *\r\n * @param value Value to truncate\r\n * @param decimals Number of decimal places to truncate to\r\n * @returns Truncated value\r\n */\r\nexport function truncate(value: number, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n/**\r\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\r\n *\r\n * @param x First value\r\n * @param y Second value\r\n * @param t Amount to interpolate (0 <= t <= 1)\r\n * @returns Interpolated value\r\n */\r\nexport function lerp(x: number, y: number, t: number) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n/**\r\n * Damp a value over time using a damping factor\r\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\r\n *\r\n * @param x Initial value\r\n * @param y Target value\r\n * @param lambda Damping factor\r\n * @param dt Time elapsed since the last update\r\n * @returns Damped value\r\n */\r\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\r\n}\r\n\r\n/**\r\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n * {@link https://anguscroll.com/just/just-modulo}\r\n *\r\n * @param n Dividend\r\n * @param d Divisor\r\n * @returns Modulo\r\n */\r\nexport function modulo(n: number, d: number) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\n/**\r\n * Dimensions class to handle the size of the content and wrapper\r\n *\r\n * @example\r\n * const dimensions = new Dimensions(wrapper, content)\r\n * dimensions.on('resize', (e) => {\r\n *   console.log(e.width, e.height)\r\n * })\r\n */\r\nexport class Dimensions {\r\n  width = 0\r\n  height = 0\r\n  scrollHeight = 0\r\n  scrollWidth = 0\r\n\r\n  // These are instanciated in the constructor as they need information from the options\r\n  private debouncedResize?: (...args: unknown[]) => void\r\n  private wrapperResizeObserver?: ResizeObserver\r\n  private contentResizeObserver?: ResizeObserver\r\n\r\n  constructor(\r\n    private wrapper: HTMLElement | Window | Element,\r\n    private content: HTMLElement | Element,\r\n    { autoResize = true, debounce: debounceValue = 250 } = {}\r\n  ) {\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper instanceof Window) {\r\n        window.addEventListener('resize', this.debouncedResize, false)\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n\r\n    if (this.wrapper === window && this.debouncedResize) {\r\n      window.removeEventListener('resize', this.debouncedResize, false)\r\n    }\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce<CB extends (...args: any[]) => void>(\r\n  callback: CB,\r\n  delay: number\r\n) {\r\n  let timer: number | undefined\r\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      timer = undefined\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","/**\r\n * Emitter class to handle events\r\n * @example\r\n * const emitter = new Emitter()\r\n * emitter.on('event', (data) => {\r\n *   console.log(data)\r\n * })\r\n * emitter.emit('event', 'data')\r\n */\r\nexport class Emitter {\r\n  private events: Record<\r\n    string,\r\n    Array<(...args: unknown[]) => void> | undefined\r\n  > = {}\r\n\r\n  /**\r\n   * Emit an event with the given data\r\n   * @param event Event name\r\n   * @param args Data to pass to the event handlers\r\n   */\r\n  emit(event: string, ...args: unknown[]) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i]?.(...args)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a callback to the event\r\n   * @param event Event name\r\n   * @param cb Callback function\r\n   * @returns Unsubscribe function\r\n   */\r\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback from the event\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  /**\r\n   * Remove all event listeners and clean up\r\n   */\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private __rafID: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n\n      const overflow = getComputedStyle(this.rootElement)[\n        property as keyof CSSStyleDeclaration\n      ] as string\n\n      if (['hidden', 'clip'].includes(overflow)) {\n        this.internalStop()\n      } else {\n        this.internalStart()\n      }\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n    const anchor = path.find(\n      (node) =>\n        node instanceof HTMLAnchorElement &&\n        (node.getAttribute('href')?.startsWith('#') ||\n          node.getAttribute('href')?.startsWith('/#') ||\n          node.getAttribute('href')?.startsWith('./#'))\n    ) as HTMLAnchorElement | undefined\n    if (anchor) {\n      const id = anchor.getAttribute('href')\n\n      if (id) {\n        const options =\n          typeof this.options.anchors === 'object' && this.options.anchors\n            ? this.options.anchors\n            : undefined\n\n        let target: number | string = `#${id.split('#')[1]}`\n        if (['#', '/#', './#', '#top', '/#top', './#top'].includes(id)) {\n          target = 0\n        }\n\n        this.scrollTo(target, options)\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n            // immediate: !hasTouchInertia,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = this.options.lerp,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n","{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.8\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:main\": \"npm publish\",\n    \"publish:dev\": \"npm publish --tag dev\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n"],"names":["clamp","min","input","max","Math","Animate","isRunning","value","from","to","currentTime","lerp","duration","easing","onUpdate","advance","deltaTime","this","completed","linearProgress","easedProgress","x","y","lambda","t","exp","damp","round","stop","fromTo","_ref","lerp2","onStart","Dimensions","constructor","wrapper","content","autoResize","debounce","debounceValue","arguments","length","undefined","debouncedResize","callback","delay","timer","_len","args","Array","_key","context","clearTimeout","setTimeout","apply","resize","Window","window","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","width","height","scrollHeight","scrollWidth","destroy","disconnect","removeEventListener","onWrapperResize","onContentResize","innerWidth","innerHeight","clientWidth","clientHeight","limit","Emitter","events","emit","event","callbacks","_len2","_key2","i","on","cb","push","filter","off","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","touchStart","lastDelta","emitter","clientX","clientY","targetTouches","deltaX","deltaY","deltaMode","defaultEasing","pow","Lenis","_isScrolling","_isStopped","_isLocked","_preventNextNativeScrollEvent","_resetVelocityTimeout","__rafID","isTouching","time","userData","lastVelocity","velocity","direction","targetScroll","animatedScroll","animate","dimensions","virtualScroll","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","lenisVersion","updateClassName","actualScroll","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","rootElement","onTransitionEnd","requestAnimationFrame","raf","cleanUpClassName","cancelAnimationFrame","e","CustomEvent","isScrolling","stopPropagation","dispatchScrollendEvent","dispatchEvent","bubbles","detail","lenisScrollEnd","propertyName","includes","property","isHorizontal","overflow","getComputedStyle","internalStop","internalStart","setScroll","scroll","scrollTo","left","behavior","top","anchor","composedPath","find","node","HTMLAnchorElement","getAttribute","startsWith","id","target","split","button","reset","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isClickOrTap","isStopped","isLocked","isUnknownGesture","slice","indexOf","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","delta","abs","isSyncTouch","hasTouchInertia","sign","programmatic","lastScroll","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","querySelector","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","_ref2","Date","now","cache","_lenis","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","computedStyle","overflowXString","overflowX","overflowYString","overflowY","maxScroll","hasOverflow","isScrollable","scrollLeft","scrollTop","scrollX","scrollY","n","d","progress","isSmooth","className","trim","replace"],"sourceRoot":""}